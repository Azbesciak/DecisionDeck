package pl.poznan.put.topsisimport org.xmcda.ProgramExecutionResultimport org.xmcda.XMCDAimport org.xmcda.parsers.xml.xmcda_v3.XMCDAParserimport pl.poznan.put.xmcda.Utilsimport pl.poznan.put.xmcda.Utils.loadXMCDAv3import java.io.Fileimport kotlin.system.exitProcess/** * */object TOPSISCLI_XMCDAv3 {    @Throws(Utils.InvalidCommandLineException::class)    @JvmStatic    fun main(args: Array<String>) {        val params = Utils.parseCmdLineArguments(args)        val indir = params.inputDirectory        val outdir = params.outputDirectory        val prgExecResults = File(outdir, "messages.xml").also { it.parentFile.mkdirs() }        val executionResult = ProgramExecutionResult()        val xmcda = loadXmcda(indir, executionResult, prgExecResults)        val inputs = parseInput(xmcda, prgExecResults, executionResult)        val results = calculateResults(inputs, executionResult, prgExecResults)        val xmcdaResults = TopsisOutputsHandler.convert(results)        writeResults(xmcdaResults, outdir, executionResult, prgExecResults)    }    private fun writeResults(x_results: Map<String, XMCDA>, outdir: String?, executionResult: ProgramExecutionResult, prgExecResults: File) {        val parser = XMCDAParser()        x_results.keys.forEach { key ->            val outputFile = File(outdir, "$key.xml")            try {                parser.writeXMCDA(x_results[key], outputFile, TopsisOutputsHandler.xmcdaV3Tag(key))            } catch (throwable: Throwable) {                val err = "Error while writing $key.xml, reason: "                executionResult.addError(Utils.getMessage(err, throwable))                outputFile.delete()            }        }        Utils.writeProgramExecutionResultsAndExit(prgExecResults, executionResult, Utils.XmcdaVersion.v3)    }    private fun parseInput(xmcda: XMCDA, prgExecResults: File, executionResult: ProgramExecutionResult) =            try {                TopsisInputsHandler.checkAndExtractInputs(xmcda)            } catch (t: Throwable) {                writeErrorMessageAndExit(t, "Could not parse inputs: ", prgExecResults, executionResult)            }    private fun calculateResults(inputs: Inputs, executionResult: ProgramExecutionResult, prgExecResults: File) =            try {                Topsis(inputs.alternatives, inputs.criteria).calculate()            } catch (t: Throwable) {                writeErrorMessageAndExit(t, "The calculation could not be performed, reason: ", prgExecResults, executionResult)            }    private fun writeErrorMessageAndExit(t: Throwable, message: String, prgExecResults: File, executionResult: ProgramExecutionResult): Nothing {        executionResult.addError(Utils.getMessage(message, t))        Utils.writeProgramExecutionResultsAndExit(prgExecResults, executionResult, Utils.XmcdaVersion.v3)        exitProcess(-1)    }    private fun loadXmcda(indir: String, executionResult: ProgramExecutionResult, prgExecResults: File): XMCDA {        val xmcda = XMCDA()        loadXMCDAv3(xmcda, File(indir, "alternatives.xml"), true, executionResult, "alternatives")        loadXMCDAv3(xmcda, File(indir, "criteria.xml"), true, executionResult, "criteria")        loadXMCDAv3(xmcda, File(indir, "performance.xml"), true, executionResult, "performanceTable")        loadXMCDAv3(xmcda, File(indir, "weights.xml"), true, executionResult, "criteriaValues")        loadXMCDAv3(xmcda, File(indir, "criteria_scales.xml"), true, executionResult, "criteriaScales")        // We have problems with the inputs, its time to stop        if (!(executionResult.isOk || executionResult.isWarning)) {            Utils.writeProgramExecutionResultsAndExit(prgExecResults, executionResult, Utils.XmcdaVersion.v3)        }        return xmcda    }}