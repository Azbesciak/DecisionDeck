package pl.poznan.put.topsisimport org.xmcda.CriteriaValuesimport org.xmcda.QuantitativeScaleimport org.xmcda.Scale.PreferenceDirection.*import org.xmcda.XMCDAimport pl.poznan.put.xmcda.InputsHandlerobject TopsisInputsHandler : InputsHandler<Inputs> {    /**     * This class contains every element which are needed to compute     * TOPSIS.<br></br>     * It is populated by [TopsisInputsHandler.checkAndExtractInputs].     */    /**     * @param xmcda     * @return     */    override fun checkAndExtractInputs(xmcda: XMCDA): Inputs {        // compilation error fix        xmcda.run {            require(criteria.isNotEmpty()) { "Criteria not provided" }            require(criteriaValuesList.size == 1) { "Expected criteriaValue to contain exactly one list, got ${criteriaValuesList.size}" }            require(criteriaScalesList.isNotEmpty()) { "Criteria scales not provided" }            require(alternatives.isNotEmpty()) { "Alternatives not provided" }        }        xmcda.run {            val weights = criteriaValuesList.first()            val criteriaTypes = getTypesOfCriteria()            val criteria = createCriteria(weights, criteriaTypes)            val alternatives = extractAlternatives(criteria)            return Inputs(alternatives, criteria.unzip().second)        }    }    private fun XMCDA.extractAlternatives(criteria: List<Pair<org.xmcda.Criterion, Criterion>>): List<TopsisAlternative> {        require(performanceTablesList.size == 1) { "Expected performanceTable to contain only one list, got ${performanceTablesList.size}" }        val performances = performanceTablesList.first()        require(!performances.hasMissingValues()) {"performanceTable has missing values"}        return alternatives.map { alt ->            val criteriaMap = criteria.map { (xmcdaCryt, cryt) -> cryt to performances.getValue(alt, xmcdaCryt).toString().toDouble() }.toMap()            TopsisAlternative(alt.id(), criteriaMap)        }    }    private fun XMCDA.createCriteria(weights: CriteriaValues<*>, criteriaTypes: Map<org.xmcda.Criterion, CriteriaType>) =            criteria.map {                val weightValue = requireNotNull(weights[it]) { "weight for criterion ${it.id()} not found" }                val weight = weightValue.first().value.toString().toDouble()                val criterionType = requireNotNull(criteriaTypes[it]) { "criteria type for criterion ${it.id()} not found" }                it to Criterion(it.id(), weight, criterionType)            }    private fun XMCDA.getTypesOfCriteria() =            criteriaScalesList.first().mapValues {                require(it.value.size == 1) { "Expected only one criterion scale for ${it.key.id()}, got ${it.value.size}" }                val preferenceDirection = requireNotNull((it.value.first() as QuantitativeScale<*>).preferenceDirection) {                    "PreferenceDirection not set for ${it.key.id()}"                }                when (preferenceDirection) {                    MIN -> CriteriaType.COST                    MAX -> CriteriaType.PROFIT                }            }}data class Inputs(        val alternatives: List<TopsisAlternative>,        val criteria: List<Criterion>)