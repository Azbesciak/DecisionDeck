package pl.poznan.put.topsisimport org.xmcda.*import org.xmcda.Scale.PreferenceDirection.*import pl.poznan.put.xmcda.InputsHandlerclass TopsisInputsHandler<T>(        private val TableNames: List<String>,        private val inputSupplier: (List<List<TopsisAlternative>>, List<Criterion>) -> T) : InputsHandler<T> {    /**     * This class contains every element which are needed to compute     * TOPSIS.<br></br>     * It is populated by [TopsisInputsHandler.checkAndExtractInputs].     */    /**     * @param xmcda     * @return     */    override fun checkAndExtractInputs(xmcda: XMCDA): T {        // compilation error fix        xmcda.run {            require(criteria.isNotEmpty()) { "Criteria not provided" }            require(criteriaValuesList.size == 1) { "Expected criteriaValue to contain exactly one list, got ${criteriaValuesList.size}" }            require(criteriaScalesList.isNotEmpty()) { "Criteria scales not provided" }            require(alternatives.isNotEmpty()) { "Alternatives not provided" }        }        xmcda.run {            val weights = criteriaValuesList.first()            val criteriaTypes = getTypesOfCriteria()            val criteria = createCriteria(weights, criteriaTypes)            validatePerformanceTablesNo()            val alternatives = extractAlternatives(criteria)            return inputSupplier(alternatives, criteria.unzip().second)        }    }    private fun XMCDA.extractAlternatives(criteria: List<Pair<org.xmcda.Criterion, Criterion>>) =            performanceTablesList.zip(TableNames).map { it.first.extractFor(criteria, it.second) }    private fun XMCDA.validatePerformanceTablesNo() {        require(performanceTablesList.size == TableNames.size) {            "Expected exactly ${TableNames.size} performanceTable${if (TableNames.size == 1) "" else "s"}, got ${performanceTablesList.size}"        }    }    private fun XMCDA.createCriteria(weights: CriteriaValues<*>, criteriaTypes: Map<org.xmcda.Criterion, CriteriaType>) =            criteria.map {                val weightValue = requireNotNull(weights[it]) { "weight for criterion ${it.id()} not found" }                val weight = weightValue.first().value.toString().toDouble()                val criterionType = requireNotNull(criteriaTypes[it]) { "criteria type for criterion ${it.id()} not found" }                it to Criterion(it.id(), weight, criterionType)            }    private fun XMCDA.getTypesOfCriteria() =            criteriaScalesList.first().mapValues {                require(it.value.size == 1) { "Expected only one criterion scale for ${it.key.id()}, got ${it.value.size}" }                val preferenceDirection = requireNotNull((it.value.first() as QuantitativeScale<*>).preferenceDirection) {                    "PreferenceDirection not set for ${it.key.id()}"                }                when (preferenceDirection) {                    MIN -> CriteriaType.COST                    MAX -> CriteriaType.PROFIT                }            }    private fun PerformanceTable<*>.extractFor(criteria: List<Pair<org.xmcda.Criterion, Criterion>>, name: String): List<TopsisAlternative> {        require(!hasMissingValues()) { "'$name' performanceTable has missing values" }        return alternatives.map { alt ->            val criteriaMap = criteria.map { (xmcdaCryt, cryt) -> cryt to getValue(alt, xmcdaCryt).toString().toDouble() }.toMap()            TopsisAlternative(alt.id(), criteriaMap)        }    }}data class TopsisInputs(        val alternatives: List<TopsisAlternative>,        val criteria: List<Criterion>)val singleInputTopsisHandler = TopsisInputsHandler(listOf("main")) { alt, crs ->    TopsisInputs(alt.first(), crs)}fun TopsisAlternative.asPerformance() = listOf(this).asPerformance()fun List<TopsisAlternative>.asPerformance() = XMCDA().apply {    performanceTablesList += performanceFrom(this@asPerformance)}private fun performanceFrom(alternatives: List<TopsisAlternative>) =        PerformanceTable<Double>().apply {            alternatives.forEach { plusAssign(it) }        }private operator fun PerformanceTable<Double>.plusAssign(alt: TopsisAlternative) {    val xmcdaAlt = Alternative(alt.name)    alt.criteriaValues.forEach {        put(xmcdaAlt, Criterion(it.key.name), it.value)    }}